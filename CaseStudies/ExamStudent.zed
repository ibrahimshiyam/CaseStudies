\documentclass{article}
\usepackage[cntbysection,colour]{circus}

\begin{document}
Case Study on hiding

\begin{zsection}
  \SECTION ExamStudent \parents standard\_toolkit
\end{zsection}

\begin{zed}
  [ EXAMINER , STUDENT , TEST ]
\end{zed}

\begin{zed}
  CANDIDATE == STUDENT \cross TEST					\\
\end{zed}

\begin{axdef}
 ex : EXAMINER
\end{axdef}

\begin{schema}{State}
	examiners   : \finset EXAMINER					\\
	candidates 	: \finset CANDIDATE					\\
	smarks 		: CANDIDATE \pfun \nat				\\
	exassigned	: EXAMINER \pfun (\finset CANDIDATE)\\
\where
	\dom exassigned \subseteq examiners				\\
	\bigcup (\ran exassigned) \subseteq candidates	\\
	ex \in examiners
\end{schema}

\begin{circus}
	\circchannel\ inex    : EXAMINER 				\\
	\circchannel\ incand  : CANDIDATE 				\\
	\circchannel\ outmark : \nat 					\\
\end{circus}

\begin{circus}
	\circprocess\ ExamSys \circdef \circbegin   
\end{circus}

\begin{circusaction}
    \circstate\ State  								\\
    Init ~~==~~ [~ State~' | 	
    				examiners'  = \emptyset \land 
    				candidates' = \emptyset \land
    				smarks' 	= \emptyset \land  
    				exassigned' = \emptyset ~]  
\end{circusaction}

\begin{schema}{getStMarks}
	\Xi State										\\
	e?		: EXAMINER								\\
	c?		: CANDIDATE								\\
	marks! 	: \nat	
\where
	c? \in  (exassigned\ e?) 						\\
	marks! = smarks\ c?  
\end{schema}

\begin{schema}{addMark}
  	\Delta State									\\
  	c? 		: CANDIDATE								\\
  	mark? 	: \nat									\\ 
\where
  	c? \notin candidates	\land 
  	smarks' = smarks \cup \{(c? \mapsto mark?)\}	
\end{schema}

\begin{schema}{updMark}
  	\Delta State									\\
  	c? 		: CANDIDATE								\\
  	mark? 	: \nat									\\ 
\where
  	c? \in candidates		\land 
  	smarks' = smarks \oplus \{(c? \mapsto mark?)\}	
\end{schema}

\begin{schema}{hideCond}
  	\Xi State										\\
\where  
	\exists State~_1 ; e:EXAMINER @
			e = ex \land
			\forall s:STUDENT;t:TEST @ 
				(s,t) \in candidates \land
					(s,t) \notin (exassigned\ ex) \implies 
						smarks (s,t) \neq smarks_1 (s,t)
\end{schema}

			
%begin{zed}
%  FailuresExpected ==
%  \\ %
%  \t1 [~ Failures; failureacks: \power UnitFailure | failureacks
%  \subseteq noacks ~]
%  \also %
%  AcceptFailureAcks ==
%  \\ %
%  \t1 [~ \Delta Failures; FailuresExpected | noacks' = noacks
%  \setminus failureacks ~]
%\end{zed}

%begin{zed}
%    RingState ~~== ~~ [~ ring : \seq \nat | \#~ring = maxring ~] \\
%    CBufferState ~~==~~ (ControllerState \lor RingState)
%\end{zed}

\begin{circusaction}
    Output ~~\circdef~~
            (\circvar\ esal: \nat \circspot in?e \then in?r \then 
             \lschexpract reqSal \rschexpract \circseq \\ 
             \t4(out~!esal \then \Skip))
\end{circusaction}
\begin{circusaction}
    HideSal ~~\circdef~~ \lschexpract hideH \rschexpract
\end{circusaction}
\begin{circusaction}
    AddEmp ~~\circdef~~ in?e \then in?r \then insal?d \then \lschexpract addEmp \rschexpract
\end{circusaction}
\begin{circusaction}
    UpdSal ~~\circdef~~ \lschexpract hideH \rschexpract
\end{circusaction}
\begin{circusaction}
   \t1 \circspot InitHRState \circseq (\circmu\ X \circspot (		
   					 (AddEmp \circseq HideSal 	\\
   					\t7 \extchoice 					\\
   					\t7 UpdSal \circseq HideSal 	\\
   					\t7 \extchoice 					\\
   					\t7 AddEmp \circseq HideSal 	
   					) \circseq X))
\end{circusaction}
\begin{circus}
    \circend
\end{circus}


This specification describes ...



\end{document}